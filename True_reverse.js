let arr = [1,2,3,4,5,6];

let exchange = (arr, index1, index2,) => {// запятая лишняя,но не критично
    let buffer = arr[0]; // почему 0? мы ж меняем местами arr[index1] и arr[index2].
    let arr[5] = buffer; // вот этим шагом м ы теряем значение 5 го элемента, с концами. и теперь у нас значение из 0 вого элемента хранится в буфере, под 0вым индексом и под 5ым индексом
    return exchange() // не понял маневра - это зачем?
}

// подсказки:
// о чем нужно помнить: 
// 1 - мы пишем функцию для того чтобы решить часть задачи по реверсу массива. Нам нужно иметь возможность не задумываясь менять элементы местами
// 2 - мы не должны тертяь значения. Каждую операцию надо анализировать - не теряем ли мы после этого данные?
// 3 - методы проверки:
//  console.log(exchange([1,2,3], 0,2)) // должно вывести 3,2,1
//  console.log(exchange([1,2,3,4,5] 0,2)) // должно вывести 3,2,1,4,5
//  console.log(exchange([1,2,3,4,5] 0,0)) // должно вывести 1,2,3,4,5
// алгоритм пошагово:
// 1) определяем сигнатуру функции. Сигнатура - это входящие аргумент и результат. Функция должна принимать массив и два индекса, а возвращать ничего. 
// Потому что мы меняем местами элементы в исходном массиве. Но чтобы проще было через консоль тестироваться - давай возвращать тот массив который нам передали в аргументе
// let exchange = (arr, index1, index2) => {
// /*do something*/
// return arr;
//}
// 2) реализуем обмен занчениями "методом трех коробочек"
// 2.1 две коробочки это arr[index1] и arr[index2], третья - наша локальная переменная buf
// 2.2 первое действие: сохраняем значение arr[index1] в промежуточную переменную.
// состояние: в первой и вторйо коробочках - свои исходные значения, в буфере - значение arr[index1]
// 2.2 теперь мы имеем два раза сохраненное значение arr[index1], соответсвенно нам не страшно его потерять. 
//  arr[index1] = arr[index2]
// состояние: теперь у нас в массиве arr[index2]===arr[index1], и в буфере лежит прошлое значени arr[index1]
// ...
